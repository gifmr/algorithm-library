{
	"cout_yes_no":{
		"prefix": "yesno",
		"body":[
			"if($1) cout<<\"Yes\"<<endl;",
  		"else cout<<\"No\"<<endl;"
		]
	},
	"priority_queue_asc":{
		"prefix": "pqasc",
		"body":[
			"priority_queue<$1, vector<$1>, greater<$1>>"
		]
	},
	"add_mul":{
		"prefix": "addmul",
		"body":[
			"void add(ll& a, ll b){",
			"\ta = (a+b) % MOD;",
			"}",
			"",
			"void mul(ll& a, ll b){",
			"\ta = (a*b) % MOD;",
			"}"
		]
	},
	"cout_fail":{
		"prefix": "fail",
		"body":[
			"void fail(){",
			"\tcout << 0 << endl;",
			"\texit(0);",
			"}"
		]
	},
	"memset-inf":{
		"prefix": "memsetinf",
		"body": [
			"memset($1,0x3f,sizeof($1));"
		]
	},
	"loop-for":{
		"prefix": "loopf",
		"body":[
			"for($1){",
			"\t",
			"}"
		]
	},
	"rsort":{
		"prefix": "rsort",
		"body": [
			"sort($1.rbegin(),$1.rend());"
		]
	},
	"cout-space":{
		"prefix": "sppp",
		"body":[
			"<<\" \"<<"
		]
	},
	"coutd":{
		"prefix": "coutd",
		"body": "cout<<std::setprecision(10)<<$1<<endl;"
	},
	"replace-all":{
		"prefix": "replace-all",
		"body":[
			"regex_replace($1, regex(\"$2\"), \"$3\");"
		]
	},
	"eratosthenes":{
		"prefix": "eratos",
		"body":[
			"const ll maxn_eratosthenes = 100005;",
			"bool _is_prime[maxn_eratosthenes];",
			"vector<ll> P;",
			"",
			"void eratosthenes(const ll N)",
			"{",
			"\tfor (ll i = 0; i <= N; i++) {",
			"\t\t_is_prime[i] = true;",
			"\t}",
			"\t_is_prime[0]=_is_prime[1]=false;",
			"\tfor (ll i = 2; i <= N; i++) {",
			"\t\tif (_is_prime[i]) {",
			"\t\t\tfor (ll j = 2 * i; j <= N; j += i) {",
			"\t\t\t\t_is_prime[j] = false;",
			"\t\t\t}",
			"\t\t\tP.emplace_back(i);",
			"\t\t}",
			"\t}",
			"}"
		]
	},
	"union-find":{
		"prefix": "uf",
		"body":[
			"class UnionFind{",
			"private:",
			"\tvector<ll> Parent; ",
			" public:",
			"\tUnionFind(ll N){",
			"\t\tParent = vector<ll>(N, -1);",
			"\t}",
			"\t",
			"\tll root(ll A){",
			"\t\tif(Parent[A] < 0) return A;",
			"\t\treturn Parent[A] = root(Parent[A]);",
			"\t}",
			"\t",
			"\tll size(ll A){",
			"\t\treturn -Parent[root(A)]; ",
			"\t}",
			"\t",
			"\tbool connect(ll A, ll B){",
			"\t\tA = root(A);",
			"\t\tB = root(B);",
			"\t\tif(A == B){",
			"\t\t\treturn false;",
			"\t\t}",
			"\t\tif(size(A) < size(B)) swap(A, B);",
			"\t\tParent[A] += Parent[B];",
			"\t\tParent[B] = A;",
			"\t\treturn true;",
			"\t}",
			"\t",
			"\tbool isSame(ll A, ll B){",
			"\t\treturn root(A) == root(B);",
			"\t}",
			"};"
		]
	},
	"combination":{
		"prefix": "comb",
		"body":[
			"ll modpow(ll a, ll n) {",
			"\tll res = 1;",
			"\twhile (n > 0) {",
			"\t\tif (n & 1) res = res * a % MOD;",
			"\t\t(a *= a) %= MOD;",
			"\t\tn >>= 1;",
			"\t}",
			"\treturn res;",
			"}",
			"",
			"const ll maxf = 10000000;",
			"ll fact[maxf+5];",
			"ll ifact[maxf+5];",
			"",
			"void fact_init(){",
			"\tfact[0] = 1;",
			"\tfor(ll i=1; i<=maxf; i++) fact[i] = (fact[i-1] * i) % MOD;",
			"\tifact[maxf]=modpow(fact[maxf],MOD-2);",
			"\tfor(ll i=maxf; i>=1; i--) ifact[i-1] = (ifact[i] * i) % MOD;",
			"}",
			"",
			"ll comb(ll n, ll r){",
			"\tif(n<r || n<0 || r<0) return 0;",
			"\tif(fact[0] == 0) fact_init();",
			"\treturn ((fact[n] * ifact[n-r]) % MOD * ifact[r]) % MOD;",
			"}",
			"",
			"ll naive_comb(ll n, ll r){",
			"\tll res = 1;",
			"\tfor (ll i = n; i > n - r; i--) res = res * i % MOD;",
			"\tfor (ll i = 1; i <= r; i++) res = (res * modpow(i, MOD-2)) % MOD;",
			"\treturn res;",
			"}"
		]
	},
	"mod-pow":{
		"prefix": "mod-pow",
		"body": [
			"ll modpow(ll a, ll n) {",
			"\tll res = 1;",
			"\twhile (n > 0) {",
			"\t\tif (n & 1) res = res * a % MOD;",
			"\t\t(a *= a) %= MOD;",
			"\t\tn >>= 1;",
			"\t}",
			"\treturn res;",
			"}"
		]
	},
	"math-tools":{
		"prefix": "mathtools",
		"body":[
			"ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }",
			"ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }",
			"",
			"ll ngcd(vector<ll> a) {",
			"\tll res = a[0];",
			"\tfor(ll i=1; i<a.size() && res!=1; i++) res = gcd(a[i], res);",
			"\treturn res;",
			"}",
			"ll nlcm(vector<ll> a){",
			"\tll res = a[0];",
			"\tfor(ll i=1; i<a.size(); i++) res = lcm(a[i], res);",
			"\treturn res;",
			"}",
			"bool is_prime(ll n) {",
			"\tif(n < 2) return false;",
			"\tfor (ll i = 2; i * i <= n; i++) if (n % i == 0) return false;",
			"\treturn true;",
			"}",
			"ll digsum(ll n) {",
			"\tll res=0;",
			"\twhile(n) res += n%10, n /= 10;",
			"\treturn res;",
			"}",
			"ll digcnt(ll n){",
			"\tll res=0;",
			"\twhile(n) res++, n /= 10;",
			"\treturn res;",
			"}",
			"vector<ll> divisor(ll n) {",
			"\tvector<ll> res;",
			"\tfor (ll i = 1; i * i <= n; i++) {",
			"\t\tif (n % i == 0) {",
			"\t\t\tres.push_back(i);",
			"\t\t\tif (i != n / i) res.push_back(n / i);",
			"\t\t}",
			"\t}",
			"\tsort(res.begin(), res.end());",
			"\treturn res;",
			"}",
			"map<ll, ll> prime_factor(ll n) {",
			"\tmap<ll, ll> res;",
			"\tfor (ll i = 2; i * i <= n; i++) {",
			"\t\twhile (n % i == 0) ++res[i], n /= i;",
			"\t}",
			"\tif (n != 1) res[n] = 1;",
			"\treturn res;",
			"}"
		]	
	},
	"graph-tools":{
		"prefix": "graf",
		"body":[
			"const ll dy[] = {0, 1, 0, -1, -1, 1, 1, -1};",
			"const ll dx[] = {1, 0, -1, 0, 1, 1, -1, -1};",
			"",
			"inline bool inside(ll y, ll x, ll H, ll W) {",
			"\t\treturn (y >= 0 && x >= 0 && y < H && x < W);",
			"}"
		]
	},
	"bit-count":{
		"prefix":"bit-count",
		"body":[
			"ll bitcount(ll x){",
			"\tif(x==0) return 0;",
			"\treturn bitcount(x>>1)+(x&1);",
			"}"
		]
	},
	"bellman-ford":{
		"prefix":"bellman-ford",
		"body":[
			"const ll maxn_bellmanford=2505;",
			"vector<vll> G(maxn_bellmanford);",
			"bool reachableFrom1[maxn_bellmanford];",
			"void dfs(ll v){",
			"\tif(reachableFrom1[v]) return;",
			"\treachableFrom1[v]=true;",
			"\tfor(auto nv: G[v]){",
			"\t\tdfs(nv);",
			"\t}",
			"}",
			"",
			"vector<vll> rG(maxn_bellmanford);",
			"bool reachableToN[maxn_bellmanford];",
			"void rdfs(ll v){",
			"\tif(reachableToN[v]) return;",
			"\treachableToN[v]=true;",
			"\tfor(auto nv: rG[v]){",
			"\t\trdfs(nv);",
			"\t}",
			"}",
			"",
			"ll n,m;",
			"vector<tuple<ll,ll,ll>> es;",
			"ll dist[maxn_bellmanford];",
			"bool ok[maxn_bellmanford];",
			"",
			"bool bellmanford(ll s){",
			"\tfill(dist,dist+n,INF);",
			"\tdist[s]=0;",
			"\tbool update=true;",
			"\tll cnt=0;",
			"\twhile(update){",
			"\t\tupdate=false;",
			"\t\tfor(auto e: es){",
			"\t\t\tll a,b,c;",
			"\t\t\ttie(a,b,c)=e;",
			"\t\t\tif(!ok[a]||!ok[b]) continue;",
			"\t\t\tif(chmin(dist[b],dist[a]+c)) update=true;",
			"\t\t}",
			"\t\tif(cnt>=n){",
			"\t\t\treturn true; // has negative loop",
			"\t\t}",
			"\t\tcnt++;",
			"\t}",
			"\treturn false;",
			"}"
		]
	},
	"dijkstra":{
		"prefix": "dijkstra",
		"body":[
			"ll n,m;",
			"const ll maxn_dijkstra=200005;",
			"vector<pll> G[maxn_dijkstra];",
			"ll dist[maxn_dijkstra];",
			"",
			"void dijkstra(ll s){",
			"\tfill(dist,dist+n,LINF);",
			"\tdist[s]=0;",
			"\tpriority_queue<pll, vector<pll>, greater<pll>> q;",
			"\tq.emplace(0,s);",
			"\twhile(!q.empty()){",
			"\t\tpll v=q.top(); q.pop();",
			"\t\tif(dist[v.second]<v.first) continue;",
			"\t\tfor(auto nv: G[v.second]){",
			"\t\t\tif(dist[nv.first]>dist[v.second]+nv.second){",
			"\t\t\t\tdist[nv.first]=dist[v.second]+nv.second;",
			"\t\t\t\tq.emplace(dist[nv.first],nv.first);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"}"
		]
	},
	"warshall-floyd":{
		"prefix": "warshall-floyd",
		"body": [
			"const ll maxn_warshall_floyd=505;",
			"ll dist[maxn_warshall_floyd][maxn_warshall_floyd];",
			"ll n;",
			"void warshallfloyd(){",
			"\tfor(ll k = 0; k < n; k++)",
			"\t\tfor(ll i = 0; i < n; i++)",
			"\t\t\tfor(ll j = 0; j < n; j++)",
			"\t\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);",
			"}"
		]
	},
	"longest-increasing-subsequence":{
		"prefix": "lis",
		"body": [
			"template<class T> ll lis(vector<T> a, bool is_strong=true){",
			"\tconst T INF = 1<<30;",
			"\tll n = (ll) a.size();",
			"\tvector<T> dp(n, INF);",
			"\trep(i,n){",
			"\t\tif(is_strong) *lower_bound(all(dp), a[i]) = a[i];",
			"\t\telse *upper_bound(all(dp), a[i]) = a[i];",
			"\t}",
			"\treturn lower_bound(all(dp), INF) - dp.begin();",
			"}"
		]
	},
	"split":{
		"prefix": "split",
		"body":[
			"template<class T> std::vector<std::string> split(const std::string& s, const T& separator, bool ignore_empty = 0, bool split_empty = 0) {",
			"\tstruct {",
			"\t\tauto len(const std::string&\t\t\t\t\t\t s) { return s.length(); }",
			"\t\tauto len(const std::string::value_type* p) { return p ? std::char_traits<std::string::value_type>::length(p) : 0; }",
			"\t\tauto len(const std::string::value_type\tc) { return c == std::string::value_type() ? 0 : 1; /*return 1;*/ }",
			"\t} util;",
			"\t",
			"\tif (s.empty()) { /// empty string ///",
			"\t\tif (!split_empty || util.len(separator)) return {""};",
			"\t\treturn {};",
			"\t}",
			"\t",
			"\tauto v = std::vector<std::string>();",
			"\tauto n = static_cast<std::string::size_type>(util.len(separator));",
			"\tif (n == 0) {",
			"\t\tif (!split_empty) return {s};",
			"\t\tfor (auto&& c : s) v.emplace_back(1, c);",
			"\t\treturn v;",
			"\t}",
			"\t",
			"\tauto p = std::string::size_type(0);",
			"\twhile (1) {",
			"\t\tauto pos = s.find(separator, p);",
			"\t\tif (pos == std::string::npos) {",
			"\t\t\tif (ignore_empty && p - n + 1 == s.size()) break;",
			"\t\t\tv.emplace_back(s.begin() + p, s.end());",
			"\t\t\tbreak;",
			"\t\t}",
			"\t\tif (!ignore_empty || p != pos)",
			"\t\t\tv.emplace_back(s.begin() + p, s.begin() + pos);",
			"\t\tp = pos + n;",
			"\t}",
			"\treturn v;",
			"}"
		]
	}
}