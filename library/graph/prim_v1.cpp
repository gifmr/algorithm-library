#include <bits/stdc++.h>
using namespace std;

// プリム法 (計算量改善前)
// 最小全域木問題で使われるアルゴリズム
// 元のグラフの頂点をすべて含む木を全域木と呼び、その中でも辺のコストの総和が最小ものを最小全域木と呼ぶ
// 1つの頂点から始め、接続される最小の辺を貪欲的に選択していくことで最小全域木を求めることができる

// 証明
// 1) Vを元のグラフの頂点の集合とする. X(⊂V)、つまり上記の1つの頂点から始めて少しずつ広げていく部分グラフ、に全域木Tが求まっており、またTを部分グラフとして含むVの最小全域木存在すると仮定する(言い換えると、元のグラフの最小全域木がTを部分グラフとして持つと仮定する)
// 2) XとX\V(Xと隣接するVの頂点)の最小コストの辺をeとし、eはv(∈X)とu(∈V\X)を結んでいるとする. 仮定よりTは元のグラフの最小全域木に含まれるが、eが含まれないとすると、eを最小全域木に追加することで閉路ができる
//    そしてこの閉路があるグラフには、eとは別のXとV\Xを結ぶ辺fが必ず存在する. eの取り方からfはe以上のコストになるため、fを取り除いてeを追加することで、存在すると仮定したeが含まれない元のグラフの最小全域木よりコストの小さい全域木を作ることができる
// 3) 2)よりTを部分グラフと含むVの最小全域木が存在すると言える. Tは最小コストの辺を選択して得られる全域木であるので、最小コストの辺を接続していけば元のグラフの最小全域木を求められることを証明できたことになる

// O(|V|^2)
// ダイクストラ法と同様にプライオリティキューを使うことにより、O(|E| log |V|)への改善が可能


const int INF = 1e9;
const int MAXV = 1005;

int cost[MAXV][MAXV]; // cost[u][v]:辺e=(u,v)のコスト(存在しない場合はINF)
int mincost[MAXV];    // 集合XからV\Xへ接続する辺の最小コスト
int used[MAXV];       // 頂点iがXに既に含まれているか
int V;                // 頂点数

int prim(){
  for(int i = 0; i < V; i++){
    mincost[i] = INF;
    used[i] = false;
  }
  
  mincost[0] = 0;
  int res = 0;
  
  while(true){
    int v = -1;
    
    // このイテレーションでXに追加する頂点vを探す
    for(int u = 0; u < V; u++){
      // 使用されていない頂点のうち、Xから接続される辺のコストが最小のものをvに格納する
      // 全ての頂点がXに含まれているならvの更新は行われない
      if(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;
    }
    
    if(v == -1) break; // 全ての頂点を接続し終わったことを意味する
    used[v] = true;
    res += mincost[v];
    
    // Xに頂点vを追加した後、頂点vから接続されるV\Xの頂点uへの最小コストを更新する. 
    // used[u]により、既にXに追加された頂点は無視できるので、以下では頂点vから接続される全ての頂点について最小コストを更新している
    for(int u = 0; u < V; u++){
      mincost[u] = min(mincost[u], cost[v][u]);
    }
  }
  return res;
}