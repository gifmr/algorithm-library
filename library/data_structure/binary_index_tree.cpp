#include <bits/stdc++.h>
using namespace std;

// Binary Index Tree(BIT)
// 計算量 L(log n)
// 次の2つを実現できる
// (1) a[1]～a[i]の和を求める. 最後の1ビットにより判定を行うため、配列は1から格納する
// (2) 上記を満たしつつ、a[i] += x の更新を行う
// 木のノード番号を2進表記にすると、最後の0の個数により区間の長さがわかるようになっている(0個なら長さ1、1個なら長さ2)

const int MAXN = 1 << 17;

// BITを格納する配列, BITの要素数
int bit[MAXN + 1], n;

// 区間の和の計算は、iから始めて、最後の1ビットを減算しながら遡っていく
// 2進数iの最後の1ビットは、i & -i で求められる. これは2の補数(0と1を逆転させた値に1を加えたもの)との論理積を意味する
// ちなみに、i -= (i & -i) は i = i & (i - 1) に変換可能. i-1により、iの最後の1ビットが1つ下がり、最後の1ビットより上の桁は影響を受けないことを利用している
int sum(int i){
  int s = 0;
  while(i > 0){
    s += bit[i];
    i -= i & -i;
  }
  return s;
}

// 和は、iから始めて、最後の1ビットを加算しながら上っていく
// 元の数列に対して順にaddを呼ぶことでBITを初期化する
void add(int i, int x){
  while(i <= n){
    bit[i] += x;
    i += i & -i;
  }
}